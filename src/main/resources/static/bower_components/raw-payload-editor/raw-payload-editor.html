<!--
@license
Copyright 2016 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
-->
<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../code-mirror/code-mirror.html">
<link rel="import" href="../paper-button/paper-button.html">
<link rel="import" href="../request-payload-editor-behavior/request-payload-editor-behavior.html">
<link rel="import" href="../paper-tooltip/paper-tooltip.html">
<link rel="import" href="../iron-resizable-behavior/iron-resizable-behavior.html">
<!--
`<raw-payload-editor>` A raw payload input editor based on CodeMirror.

The element additionally shows Encode / Decode buttons if current content type value contains
"x-www-form-urlencoded".

The element listens for `content-type-changed` custom event and updates the `contentType` property
automatically. This event is commonly used in ARC elements.

### Example
```
<raw-payload-editor content-type="application/json"></raw-payload-editor>
```

### Styling
`<raw-payload-editor>` provides the following custom properties and mixins for styling:

Custom property | Description | Default
----------------|-------------|----------
`--raw-payload-editor` | Mixin applied to the element | `{}`
`--raw-payload-editor-encode-buttons` | Mixin applied to encode / decode buttons container | `{}`

@group UI Elements
@element raw-payload-editor
@demo demo/index.html
-->
<dom-module id="raw-payload-editor">
  <template>
    <style>
    :host {
      display: block;
      @apply(--raw-payload-editor);
    }

    .encoder-buttons {
      margin: 8px 0;
      @apply(--raw-payload-editor-encode-buttons);
    }

    *[hidden] {
      display: none !important;
    }
    </style>
    <div class="encoder-buttons" hidden$="[[!encodeEnabled]]">
      <paper-button id="encodePayload" on-tap="encodeValue">encode payload</paper-button>
      <paper-button id="decodePayload" on-tap="decodeValue">decode payload</paper-button>
      <paper-tooltip animation-delay="200" for="encodePayload">Encodes payload to x-www-form-urlencoded data</paper-tooltip>
      <paper-tooltip animation-delay="200" for="decodePayload">Decodes payload to human readable form</paper-tooltip>
    </div>
    <code-mirror mode="application/json" on-value-changed="_editorValueChanged" on-paste="_onPaste"></code-mirror>
  </template>
  <script>
  Polymer({
    is: 'raw-payload-editor',

    behaviors: [
      ArcBehaviors.RequestPayloadEditorBehavior,
      Polymer.IronResizableBehavior
    ],

    /**
     * Event fire when the value of the editor change.
     * This event is not fired if `attrForOpened` is set and corresponding value is not set.
     *
     * @event payload-value-changed
     * @param {String} value Current payload value.
     */

    properties: {
      /**
       * Content-Type header value. Determines current code mirror mode.
       */
      contentType: {
        type: String,
        observer: '_onContentTypeChanged'
      },
      // Computed value, true if `contentType` contains `x-www-form-urlencoded`
      encodeEnabled: {
        type: Boolean,
        computed: '_computeEncodeEnabled(contentType)',
        value: false
      }
    },

    observers: [
      '_valueChanged(value)',
      '__isOpenedChanged(_isOpened)'
    ],

    listeners: {
      'iron-resize': 'refresh'
    },

    attached: function() {
      this.listen(window, 'content-type-changed', '_contentTypeHandler');
    },

    detached: function() {
      this.unlisten(window, 'content-type-changed', '_contentTypeHandler');
    },

    __isOpenedChanged: function(isOpened) {
      if (isOpened) {
        this.__editorValueChange = false;
        this._valueChanged(this.value);
        this.refresh();
      }
    },
    /**
     * Forces render code-mirror content.
     * Should be used to when the element becomes visible after being hidden.
     */
    refresh: function() {
      if (!this._isOpened) {
        return;
      }
      var elm = this.$$('code-mirror');
      if (!elm) {
        return; // DOM not ready
      }
      elm.editor.refresh();
    },

    /**
     * Changes CodeMirror mode when the content type value is updated.
     */
    _onContentTypeChanged: function(ct) {
      if (!ct) {
        return;
      }
      if (ct.indexOf && ct.indexOf(';') !== -1) {
        ct = ct.substr(0, ct.indexOf(';'));
      }
      this.$$('code-mirror').mode = ct;
    },
    // Computes `encodeEnabled` based on content type.
    _computeEncodeEnabled: function(ct) {
      if (!ct) {
        return false;
      }
      if (ct.indexOf && ct.indexOf('x-www-form-urlencoded') !== -1) {
        return true;
      }
      return false;
    },

    // Handler for the `content-type-changed` event. Sets the `contentType` property.
    _contentTypeHandler: function(e) {
      var event = Polymer.dom(e);
      if (event.rootTarget === this) {
        return;
      }
      var ct = e.detail.value;
      this.set('contentType', ct);
    },

    /**
     * Handler for value change.
     * If the element is opened then it will fire change event.
     */
    _valueChanged: function(value) {
      if (this._isOpened) {
        if (this.__editorValueChange) {
          this.fire('payload-value-changed', {
            value: value
          });
        } else {
          this.$$('code-mirror').value = value;
          if (this.__internalChange) {
            // from encoder / decoder
            this.fire('payload-value-changed', {
              value: value
            });
          }
        }
      }
    },
    // Called when the editor fires change event
    _editorValueChanged: function(e) {
      e.stopPropagation();

      this.__editorValueChange = true;
      this.set('value', e.detail.value);
      this.__editorValueChange = false;
    },

    _onPaste: function(e) {
      if (this.contentType !== 'application/json') {
        return;
      }
      var len;
      if (this.value) {
        len = this.value.length;
      }
      if (this._hasSelection(len)) {
        return;
      }

      var data = e.clipboardData.getData('text/plain');
      try {
        data = JSON.parse(data);
        data = JSON.stringify(data, null, 2);
        e.preventDefault();
        this.set('value', data);
      } catch (e) {}
    },

    _hasSelection: function(inputSize) {
      var el = document.activeElement;
      var start = 0;
      var end = 0;
      if (el) {
        if (typeof el.selectionStart === 'number') {
          start = el.selectionStart;
        }
        if (typeof el.selectionEnd === 'number') {
          end = el.selectionEnd;
        }
      }
      if (start === 0 && end === 0) {
        var selection = window.getSelection();
        if (selection.rangeCount === 0) {
          return false;
        }
        var range = selection.getRangeAt(0);
        start = range.startOffset;
        end = range.endOffset;
      }
      if (start === 0 && end === inputSize) {
        return false;
      }
      return start !== end;
    }
  });
  </script>
</dom-module>
